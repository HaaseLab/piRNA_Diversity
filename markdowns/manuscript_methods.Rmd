---
title: "'Cellular abundance shapes function in piRNA-guided genome defense'"
output:
  pdf_document: default
  html_document: default
---
\center
*"Pavol Genzor\*, Parthena Konstantinidou\*, Daniel Stoyko\**     *\*equal contributors*  
*Amirhossein Manzourolajdad, Celine Marlin Andrews, Alexandra R. Elchert, Constantinos Stathopoulos, Astrid D. Haase*  
  
  
This vignette describes the computational materials & methods associated with this manuscript. Please visit [**HaaseLab/piRNA_Diversity github repository**](https://github.com/HaaseLab/piRNA_Diversity) to download functions for the script. Please reffer to the GEO dataset [**GSE156058**](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE156058) associated with this study for adapter sequences and raw data. 

####
__About small RNA Libraries.__  
To be able to account for the PCR duplication when quantifying individueal piRNA sequences, cloning procedure utilized adapter sequences containing multiple random nucleotides. Each ligated read contains 10 N's or **U**nique **M**olecular **I**dentifiers **(UMIs)**. There are 8N at the 5-prime and 2N at the 3-prime of the small RNA that allows for 4^10 or 1,048,576 possible combinations. 

#### Library structure:  
5-FivePrimeAdapter--*NNNNNNNN*--**smallRNA**--*NN*--ThreePrimeAdapter-3

####
__Pre-requisites__  
* Acquire the raw sequencing data from your facility or GEO at NCBI
* Ensure that you have the appropriate 5-prime and 3-prime adapter sequences
* Ensure you have access to computing cluster and a computer with R environment
* Ensure that you have all the necessary software installed and running

####
__Vignette Content__  
  
A. DATA PREPARATION

  1. Pre-process fastq files
  2. Generate unique sequence fasta files
  3. Remove structural contaminants and align to the genome
  4. Load and process files in R.  

B. FIGURE-RELATED SCRIPTS


##  
__DATA PREPARATION__  

####
__1. Pre-process fastq files.__  
First, the raw sequencing data was cleaned up with ***cutadapt*** by removing the adapter sequences and keeping the UMIs. Refer to ***cutadapt*** manual for option description. The following commands were executed in the *bash* environment in the terminal. Remember to placeholder variables for your own sequences, directories, and files on you machine.

#####
```{r cutadapt on fastq, eval=FALSE}
bash$ # initiate appropriate vertion of cutadapt
bash$ module load cutadapt/2.3
bash$
bash$ # split the sequencing lane without trimming
bash$ cutadapt --no-trim -m 19 \
               -g FivePrimeAdapter \
               -a file\:InputFiles/ThreePrimeAdapterSequences.fa \
               -o OutputDirectory/{name}.SNT.fastq.gz \
               --untrimmed-o OutputDirectory/untrimmed.SNT.fastq.gz \
               InputDirectory/SequencingLane_R1_001.fastq.gz
bash$
bash$ # remove the constant adapter sequences
bash$ cutadapt -j 6 --trimmed-only -m 19 \
               -g FivePrimeAdapter \
               -a ThreePrimeAdapter \
               -o OutputDirectory/SampleName.10N.fastq.gz \
               InputDirectory/SampleName.SNT.fastq.gz
bash$
bash$
  
# SNT = split not trimmed, 10N = 10 UMIs
```

__2. Generate unique sequence fasta files__  

Next, the small RNAs with UMIs can be cleared of PCR duplication. Full script of all functions can be found at [***piRNA_Diversity github***](https://github.com/HaaseLab/piRNA_Diversity). In the next few chunks we will:  

* initiate R session, and load custom function
* remove PCR duplicates using UMIs
* remove UMIs
* export the cleaned reads into **.fasta** 

####
```{r load R, eval=FALSE}
# NOTE: If you are working on small files or have a lot of memory, 
#       this can be run on laptop

bash$ # initiate an R session
bash$ module load R/4.0.5  
bash$
bash$ ## enter R environment
bash$ R
```

```{r prepareFastq, eval=FALSE }
# NOTE: Below script sets up the directories and loads the functions

# IMPORTANT: directory on your machine with all functions in this vignette 
#            downloaded from github
FUN.DIR <- "/Users/YourUsername/YourDiversityScriptsFolder/"

# File directories 
FASTQ.FILE = "SampleName_conditionA_replicate1.SNT.fastq.gz"
OUTPUT.DIR = "/YourComputer/WorkingDirectory/fastaFiles/"

## Load function
source(paste0(FUN.DIR,"prepareFastq.R"))

## Run the analysis on single file
prepareFastq(FASTQ.FILE = FASTQ.FILE, 
             OUTPUT.DIR = OUTPUT.DIR, 
             REMOVE.PCR.DUPLICATES = TRUE, 
             REMOVE.UMI.N = TRUE, 
             FIVE.PRIME.N.NUMBER = 8, 
             THREE.PRIME.N.NUMBER = 2, 
             FILTER.BY.SIZE = TRUE, 
             SIZE.RANGE = c(18,32))
```

- The prepareFastq() function will generate three folders:  
  + **libraryStats**
    + contains statistics with information about processing (*.stats.txt)
  + **totalReads**
    + contains all the piRNA reads including duplicates (*.ALLREADS.fa)
  + **uniqueSequences**
    + contains only unique piRNA sequences only (*.UNIQSEQS.fa)

####
__3. Remove structural contaminants and align to the genome__  

Next, we proceed with previously generated ***\*.UNIQSEQS.fa*** and use ***STAR*** aligner to align data:  

* First, align sequences to structural genome (tRNA, rRNA, snoRNA, ...)
  * Structural RNAs can be downloaded from USCS
  * Follow STAR manual for instruction on how to prepare genome index  
  
* Second, align un-mapped sequences from previous step to specie-specific genome  
  * There are various sources where species genome files can be downloaded
  * Follow STAR manual for instruction on how to prepare genome index  
  
```{r align to structural, eval=FALSE}
# NOTE: Aligning to structural genome

bash$ # load appropriate version of aligner
bash$ module load STAR/2.5.2b
bash$
bash$ # align to structural genome
bash$ STAR  --runThreadN 6 \
            --runMode alignReads \
            --genomeDir /LocationOfYourStructuralGenome/ \
            --outSAMtype BAM SortedByCoordinate \
            --limitBAMsortRAM 10000000000 \
            --outFilterMultimapNmax 100 \
            --outFilterMismatchNmax 1 \
            --outReadsUnmapped Fastx \
            --outSAMattributes NH HI NM MD AS nM \
            --readFilesIn /InputDirectory/SampleName.UNIQSEQS.fa \
            --outFileNamePrefix /OutputDirectory/mappedToStructural/SampleName.
```

```{r align to genome, eval=FALSE}
# NOTE: Aligning to specie-specific genome
# NOTE:   - use *.Unmapped.out.mate1 file generated after 
          previous code has been executed

bash$ # align to specie genome
bash$ STAR  --runThreadN 6 \
            --runMode alignReads \
            --genomeDir /LocationOfYourSpeciesGenome/ \
            --sjdbGTFfile /LocationOfYourSpeciesFiles/gene.gtf \
            --outSAMtype BAM SortedByCoordinate \
            --limitBAMsortRAM 10000000000 \
            --outFilterMultimapNmax 100 \
            --winAnchorMultimapNmax 100 \
            --sjdbOverhang 100 \
            --outSAMattributes NH HI NM MD AS nM \
            --readFilesIn /InputDirectory/mappedToStructural/SampleName.Unmapped.out.mate1 \
            --outFileNamePrefix /OutputDirectory/mappedToGenome/SampleName.
```

__4. Load and pre-process files in the R.__  

Once the replicate ***bam** files are generated in the previous chunks, we load the data in R environment and prepare it for analysis:  

* Load data into R
* Remove potential miRNA contaminants
* Combine replicate data sets
* Calculate sequence overlap between samples
* Combine overlapped data to get Total, Common, and Rare groups
* Full script of all functions can be found at [***piRNA_Diversity github***](https://github.com/HaaseLab/piRNA_Diversity).

#####
```{r load Replicate .bams, eval=FALSE}
# NOTE: LOAD DATA INTO R

# load function
source(paste0(FUN.DIR,"filterBam.R"))

## named vector of paths
BAM.PATH.L <- c("rep1"="/Users/genzorp/Documents/GITHUB/piDiversity/data/bamFiles/FHIP/STAR/FH-Piwi-IP_1_1.Aligned.sortedByCoord.out.bam",
                "rep2"="/Users/genzorp/Documents/GITHUB/piDiversity/data/bamFiles/FHIP/STAR/FH-Piwi-IP_1_2.Aligned.sortedByCoord.out.bam",
                "rep3"="/Users/genzorp/Documents/GITHUB/piDiversity/data/bamFiles/FHIP/STAR/FH-Piwi-IP_1_3.Aligned.sortedByCoord.out.bam")

## load multiple files using lapply loop 
BAM.L <- lapply(names(BAM.PATH.L), function(s){
  message(paste0("Processing: ",s))
  filterBam(BAMFILE = BAM.PATH.L[[s]], 
            BSSPECIES = "Dmelanogaster",
            EXTENTION = ".Aligned.sortedByCoord.out.bam",
            SIMPLECIGAR = TRUE,
            INCLUDE.SECONDARY.ALIGNEMNT=FALSE,
            STANDARD.CONTIGS.ONLY = TRUE,
            GET.ORIGINAL.SEQUENCE = FALSE,
            PERFECT.MATCH.ONLY = TRUE,
            FILTER.BY.FLAG = TRUE,
            SELECTFLAG = c(0,16),
            USE.SIZE.FILTER=TRUE,
            READ.SIZE.RANGE = c(18,32),
            TAGS = c("NH","NM","MD"),
            WHAT = c("flag"), 
            SPLIT.NAME.BY = "-") })
names(BAM.L) <- names(BAM.PATH.L)
```

```{r filter miRNA from data, eval=FALSE}
# NOTE: REMOVE miRNA CONTAMINATS

# libraries
library("GenomicRanges")

# load the function
source(paste0(FUN.DIR,"miRbase2BED.R"))

# path to miRbase annotation
miRBASE.PATH = "/Users/genzorp/Documents/DATA/Annotation/Dmelanogaster/
                dm6_miRBase_dme.gff3"

# make Genomic Range
mi.GR <- makeGRangesFromDataFrame(df = miRbase2BED(miRBASEFILE = miRBASE.PATH),
                                  keep.extra.columns = TRUE)

# Filter data
BAM.L <- lapply(BAM.L, function(s){subsetByOverlaps(x = s, ranges = mi.GR, 
                                                    type = "any", invert = TRUE)})

## save ALL image to work with later
#save.image(file = "/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/
#three_filtered_bams_all.RData")

# NOTE: for simplicity only fraction of data was used here 
#       - first 500 thousand sequences

SUBSET_500K=500000
BAM.L <- lapply(BAM.L,function(s){s[1:SUBSET_500K]})

## save loaded 500K to object for faster loading later
save.image(file = "/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/
           three_filtered_bams_500K.RData")
```

```{r merge replicates, eval=TRUE, cache=TRUE}
# NOTE: COMBINE REPLICATES

# load data
#load(file = "/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/three_filtered_bams_all.RData")
load(file = "/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/three_filtered_bams_500K.RData")

# Load the function
source(paste0(FUN.DIR,"combineThreeGRS.R"))

# combine three technical replicates
BIO.REP <- suppressMessages(
  combineThreeGRS(GRL = BAM.L,
                  REPLICATE.NAMES = c("rep1","rep2","rep3"),
                  MC.CORES = 3))

# show results
BIO.REP

# all unique sequences
summary(duplicated(BIO.REP))

# save ALL
#save.image(file = "/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/three_filtered_bams_all_brep.RData")
```

* While combining replicate data sets we:
  - Counted in how many replicates is each sequence present (N)
  - Recorded the highest sequence multi-mapping score (NH-tag)
  - Calculated the sequence cumulative abundance for identical genome positions (MULT)

```{r sequence overlap, eval=TRUE, cache=TRUE}
# NOTE: CALCULATE SEQUENCE OVERLAPS

## Load the function
source(paste0(FUN.DIR,"threeSampleSequenceOverlaps.R"))

## Generate overlaps by sequence
BIOREP.OV.L <- suppressMessages(
  threeSampleSequenceOverlaps(GRL = BAM.L,
                              BSSPECIES = "Dmelanogaster",
                              MC.CORES = 3))

## show list content 
names(BIOREP.OV.L)

## save ALL
#save.image(file = "/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/three_filtered_bams_all_brep_ov.RData")
```

* The objects generated during sequence overlap process are lists:  
  - **Common** GR - found in each biological replicate
  - **Rare (Exclusive)** GR - found only in individual biological replicates
  - **Pairwise** GR - shared between pairs of biological replicates
  - **SampleInfo** table summarizing overlaps that can be use to create a Venn diagram  

```{r combining overlapped sequences, eval=TRUE, cache=TRUE}
# NOTE: COMBINTE TO GET TOTAL, COMMON, AND RARE
# BEWARE: combining large data sets can be computationally very expnesive

# TOTAL
TOTAL.GR <- suppressMessages(
  combineThreeGRS(GRL = BAM.L,
                  REPLICATE.NAMES = names(BAM.L),
                  MC.CORES = 3))

# ensure there are no duplicates
#summary(duplicated(TOTAL.GR))

## EXCLUSIVE
RARE.GR <- c(BIOREP.OV.L[["Exclusive"]][[1]],
             BIOREP.OV.L[["Exclusive"]][[2]],
             BIOREP.OV.L[["Exclusive"]][[3]])

# ensure there are no duplicates
#summary(duplicated(RARE.GR))

## COMMON
COMMON.GR <- suppressMessages(
  combineThreeGRS(GRL = BIOREP.OV.L[["Common"]],
                  REPLICATE.NAMES = names(BIOREP.OV.L[["Common"]]),
                  MC.CORES = 3))

# ensure each is found in all samples
#unique(mcols(COMMON.GR)[["N"]])

# save ALL
#save.image(file = "/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/three_filtered_bams_all_brep_ov_comb.RData")
```

* After performing all the above operation, it is convenient to identify object that are intended for analysis, and save them into a *RData object for faster loading. Otherwise, depending on the size of the samples, the data preparation will take long time.

##
__FIGURE-RELATED SCRIPTS__  

####
* __Figure 1__  
* ***"The sequence diversity of piRNAs exceeds the capacity of an individual cell and generates cell-to-cell variability"*** 
  
```{r Figure 1A, eval=TRUE, fig.align="center", cache=TRUE}
# NOTE: Figure 1A

# load saved data
load("/Users/genzorp/Documents/GITHUB/piDiversity/sessions/revisions/three_filtered_bams_all_brep_ov_comb.RData")

# load libraries
suppressPackageStartupMessages({library("data.table"); library("dplyr"); 
  library("ggplot2"); library("ggpubr"); library("GenomicRanges")})

# calculate Sequence versus Read ratio (SoR)
SoR <- lapply(names(BAM.L), function(i){
  GR <- BAM.L[[i]]
  DT <- suppressWarnings(as.data.table(GR, keep.rownames = TRUE))
  DT <- DT[,c("rn","MULT")]
  NDT <- data.table(Sample = i, 
                    Sequences = nrow(DT),
                    Reads = sum(DT[["MULT"]]), 
                    SeqPerRead = nrow(DT)/sum(DT[["MULT"]]))
  return(NDT) })

# Combine and view results
SoR <- setDT(bind_rows(SoR))
SoR

# add information and summarize
SoR[["Sample"]] <- c(paste0("OSC",1:3))
SoR[["Species"]] <- c(rep("OSC",3))
SoR[["Protein"]] <- c(rep("Piwi",3))
SoR[["Mean"]] <- mean(SoR[["SeqPerRead"]])
SoR[["SD"]] <- sd(SoR[["SeqPerRead"]])
SoR

# plot
ggplot() + theme_pubclean() +
  geom_point(data = SoR, aes(x=factor(Protein), y = Mean, colour = Protein), 
             shape = 16, size=8) + 
  geom_errorbar(data = SoR, aes(x = Protein, ymin = Mean-SD, ymax = Mean+SD), 
                colour = "black", width = 0.4, size = 0.5) +
  scale_colour_manual(values =c("darkmagenta")) +
  facet_wrap(~Species, ncol = 3, scales = "free_x") +
  scale_y_continuous(limits = c(0,0.75), breaks = seq(0,1,0.1)) +
  labs(x="", y="Sequences / Reads", fill="") + 
  theme(aspect.ratio = 8, legend.position = "none",
        strip.background = element_blank(),
        axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0.5),
        axis.text = element_text(size = 10)) 
```

```{r Figure 1B, eval=FALSE, fig.align="center", cache=TRUE}
# NOTE: Figure 1B

# in progress
```

```{r Figure 1C, eval=TRUE, fig.align="center", cache=TRUE,}
# NOTE: Figure 1C

# load quantification data
QUANT.CSV="/Users/genzorp/Documents/GITHUB/piDiversity/data/QUANT2/Thenia/piRNA_quantification_data.csv"
QUANT.DTM <- melt.data.table(data = fread(QUANT.CSV), 
                             id.vars = c("Sample"), 
                             measure.vars = c("piRNA_count","miRNA_count"), 
                             variable.name = "smallRNA",
                             value.name = "count" )
# take a peak
head(QUANT.DTM, n=3)

# published data of piRNA and miRNA quantificaiton: PMID:30193099
ZAM.PIMI.DT <- data.table("cell"=c("1_spermatocyte","2_spermatocyte","round_spermatid"),
                          "piRNA_count"=c(7800000,3900000,2500000),
                          "miRNA_count"=c(54000,26000,20000))

ZAM.PIMI.DTM <- melt.data.table(data = ZAM.PIMI.DT, id.vars = "cell",
                                variable.name = "smallRNA",
                                value.name = "count")

# plot settings
two_cols <- c("#C695AE","#726E60")

# plot the piRNA abundances
ggplot() + theme_pubclean() +
  geom_point(data = QUANT.DTM, aes(x = smallRNA, y = count, colour = smallRNA), 
             position = position_jitterdodge(), 
             size = 4, shape = 16) +
  stat_boxplot(data = QUANT.DTM, aes(x = smallRNA, y = count, fill = smallRNA), 
               geom = "errorbar", width = 0.2, colour = "#01161E") +
  geom_boxplot(data = QUANT.DTM, aes(x = smallRNA, y = count, fill = smallRNA), 
               alpha = 0.75, width = 0.5, colour = "#01161E") +
  geom_point(data = ZAM.PIMI.DTM, aes(x = smallRNA, y = count, shape = cell), 
             size = 4, position = position_nudge(x = 0.5)) +
  scale_fill_manual(values = two_cols) +
  scale_colour_manual(values = two_cols) +
  scale_y_continuous(trans = "log10", limits = c(5e3,1e7)) + 
  annotation_logticks(sides = "l") + 
  ylab("piRNA molecules / cell") + xlab("") +
  theme(aspect.ratio = 2, legend.position = "right")
```

####  
* __Figure 2__  
* ***"A skewed distribution of sequence abundance results in a few common and many rare piRNAs."***  

```{r Figure 2, eval=TRUE, cache=TRUE, fig.align="center"}
# NOTE: Figure 2A

# Load the functions
source(paste0(FUN.DIR,"simpleGRFilter.R"))
source(paste0(FUN.DIR,"simpleStepsPlot.R"))
source(paste0(FUN.DIR,"simpleMultBarPlot.R"))
source(paste0(FUN.DIR,"simpleSRViolin.R"))

# select only the sequences within desired size range
OSC.S249.BIOREP.L <- lapply(BAM.L, function(s){
  suppressMessages(
    simpleGRFilter(GR = s,  
                   SIZE.RANGE = c(24,29))) })

## Fig 2A-C

# Plot Steps
suppressMessages(
  simpleStepsPlot(GRL = OSC.S249.BIOREP.L, 
                  Y.PPM = TRUE))

# Plot fraction 
suppressMessages(
  simpleMultBarPlot(GR = OSC.S249.BIOREP.L[["rep1"]], 
                    RANGE.NAME = "rep1"))

## Fig 2D-E

# Combine ranges into list
GRL <- list("Common"=COMMON.GR, "Rare"=RARE.GR, "Total"=TOTAL.GR)

# Plot violins
suppressMessages(
  simpleSRViolin(GRL = GRL, 
                 SOURCE.DIR = FUN.DIR,
                 NH.TAG = NULL,
                 SIZE.RANGE = c(24,29), 
                 SAMPLE.ORDER = c("Total","Common","Rare"),
                 Y.PPM = TRUE))
```

####
* __Figure S2 and Figure 3B__  
* ***Metagene analysis***   

```{r Figure Supl2 and Figure 3B, eval=TRUE, cache=TRUE, fig.align="center"}
# NOTE: Metagene analysis for Figure S2 and Figure 3B

# load functions
source(paste0(FUN.DIR,"simpleGRFilter.R"))
source(paste0(FUN.DIR,"simpleMetageneTab.R"))
source(paste0(FUN.DIR,"simpleMetageneRegularPlotGG.R"))
source(paste0(FUN.DIR,"simpleSDfromGR.R"))

# Filter the data
BIO.REP.U.S249 <- suppressMessages(
  simpleGRFilter(GR = BIO.REP,
                 RANGE.NAME = "biorep1", 
                 NH.TAG = 1, 
                 SIZE.RANGE = c(24,29)))

# Generate metagene data tables
#   - For 5-prime, for 3-prime change the ALIGN.END
MG.TAB <- suppressMessages(
  simpleMetageneTab(GR = BIO.REP.U.S249, 
                    RANGE.NAME = "biorep1", 
                    BSSPECIES = "Dmelanogaster", 
                    USE.READS = TRUE, 
                    ALIGN.END = 5, 
                    EXPAND.BY = 50) )

# plot 5-prime metagene
suppressMessages(
  simpleMetageneRegularPlotGG(METAGENE.DT = MG.TAB[["frequency"]], 
                              SAMPLE.NAME = "biorep1", 
                              Y.LIMITS = c(0,100),
                              PIRNA.SIZE = 26, 
                              ASPECT.RATIO = 0.5) )


# plot size distribution of the sequences or reads
suppressMessages(
  simpleSDfromGR(GR = BIO.REP.U.S249, 
                 SAMPLE.NAME = "biorep1", 
                 USE.READS = TRUE, 
                 PLOT.FREQ = TRUE, 
                 YLIMS = c(0,40), 
                 BAR.FILL = "firebrick3",
                 BAR.LINE = NA,
                 ASPECT.RATIO = 2) )
```

####
* __Figure 3 & 4__
* ***"Precursor and processing preferences determine piRNA sequence abundance."*** 

  * Before we can plot the results we have to re-process the data by:  
      * Generate piRNA precursor index for **Rsubread** aligner
      * Export the piRNAs into new fasta file 
      * Align the piRNA sequences to piRNA precursors
      * Load the new bam files back into R
      * Filter the data
      * Count and calculate the summaries
      * Select data for plotting
      * Plot the results

```{r Figure 3 & 4, index precursor genome, eval=TRUE, cache=TRUE, results=FALSE}
# NOTE: Generate piRNA precursor index

## load library
library("Rsubread");library("GenomicRanges"); 
library("data.table"); library("ShortRead")

## Load precursors into GR
OSC.PRECURSORS.GR <- makeGRangesFromDataFrame(df = fread("/Users/genzorp/Documents/GITHUB/piDiversity/data/temp/bed/diversity_OSC_clusters_452.bed", 
                            col.names = c("chr","start","end","name","rank","strand")),
                            keep.extra.columns = TRUE)

## Extract genome sequence
OSC.PRECURSORS.SEQ <- getSeq(Dmelanogaster, OSC.PRECURSORS.GR)
names(OSC.PRECURSORS.SEQ) <- mcols(OSC.PRECURSORS.GR)[["name"]]

## Export fasta
GENOME_FA_DIR <- "/Users/genzorp/Documents/GITHUB/piDiversity/data/temp/genome_fa/"
writeFasta(object = OSC.PRECURSORS.SEQ, file = paste0(GENOME_FA_DIR,"osc_precursors.fa"))


## INDEX GENOME
GENOME_IDX_DIR <- "/Users/genzorp/Documents/GITHUB/piDiversity/data/temp/genome_rsub/"
OSC.PRECURSORS.IDX <- suppressMessages(
  buildindex(basename = paste0(GENOME_IDX_DIR,"osc_precursors"),
             reference = paste0(GENOME_FA_DIR,"osc_precursors.fa")) )
```

```{r Figure 3 & 4, export GR to fasta, eval=TRUE, cache=TRUE}
# NOTE: Export the piRNAs into new fasta file

# load function
source(paste0(FUN.DIR,"makeFastaFromGR.R"))

# make fasta from the Total, Common, and Rare Genomic Ranges file
FA_DIR = "/Users/genzorp/Documents/GITHUB/piDiversity/data/temp/granges_fa/"
suppressMessages(
  GR.SEQ.L <- makeFastaFromGR(GRL = GRL, 
                  BSSPECIES = "Dmelanogaster", 
                  SAVE.TO.FILE = TRUE, 
                  FA.DIR = FA_DIR, 
                  MC.CORES = 3 ) )
```

```{r Figure 3 & 4, align GR to precursors, eval=TRUE, cache=TRUE, results=FALSE}
# NOTE: Align the piRNA sequences to piRNA precursors

# Provide path to newly made fasta files
GR.FASTA.L <- paste0(FA_DIR,grep("*all.fa$",list.files(FA_DIR), value = TRUE))
names(GR.FASTA.L) <- c(nth(tstrsplit(list.files(FA_DIR),split="_"),1))

# Set oath for alignment output
SUBREAD_OUTPUT <- "/Users/genzorp/Documents/GITHUB/piDiversity/data/temp/output_rsub/"

# Align files to genome with Rsubread
OSC.ALIGN.PRECURSORS <- lapply(names(GR.FASTA.L),function(s){
  suppressMessages(
    aRES <- suppressMessages(
      align(index = paste0(GENOME_IDX_DIR,"osc_precursors"), 
            readfile1 = GR.FASTA.L[[s]], 
            output_file = paste0(SUBREAD_OUTPUT,s,".bam"),
            sortReadsByCoordinates = TRUE,
            maxMismatches = 1, 
            nthreads = 3,
            unique = FALSE,
            nBestLocations = 100) ) )
  return(aRES)})
```

```{r Figure 3 & 4, load force-mapped back, eval=TRUE, cache=TRUE}
# NOTE: Load the new bam files back into R

# load function
source(paste0(FUN.DIR,"filterBam.R"))

# create named vector of paths
MAPPED.GR.PATHS <- paste0(SUBREAD_OUTPUT, grep("bam$",list.files(SUBREAD_OUTPUT), value = TRUE))
names(MAPPED.GR.PATHS) <- nth(tstrsplit(grep("bam$",list.files(SUBREAD_OUTPUT), value = TRUE), split="\\."),1)

# load bam files into new object
MAPPED.BAM.L <- lapply(names(MAPPED.GR.PATHS), function(s){
  message(paste0("Processing: ",s))
  suppressMessages(
    filterBam(BAMFILE = MAPPED.GR.PATHS[[s]], 
              BSSPECIES = "Dmelanogaster",
              EXTENTION = ".bam",
              STANDARD.CONTIGS.ONLY = FALSE,
              TAGS = c("NH","NM"),
              SPLIT.NAME.BY = "_")) })
names(MAPPED.BAM.L) <- names(MAPPED.GR.PATHS)
```

```{r Figure 3 & 4, filter force-mapped, eval=TRUE, cache=TRUE}
# NOTE: Filter the data 

# load function
source(paste0(FUN.DIR,"simpleGRFilter.R"))

# filter conditions
#  - only single mappers (NH=1)
#  - appropriate size range (24-29-nt long)
#  - originate from piRNA precursor (STRAND=YES)

MAPPED.FILTERED.BAM.L <- lapply(names(MAPPED.BAM.L),function(r){
  filtered.GR <- suppressMessages(
    simpleGRFilter(GR = MAPPED.BAM.L[[r]],
                   RANGE.NAME = r, 
                   NH.TAG = 1, 
                   SIZE.RANGE = c(24,29), 
                   STRAND = "YES", 
                   SEQNAMES.SPLIT = ":") )
  seqlevels(filtered.GR) <- seqlevelsInUse(filtered.GR)
  return(filtered.GR) })
names(MAPPED.FILTERED.BAM.L) <- names(MAPPED.BAM.L)
```

```{r Figure 3 & 4, count and calculate summaries, eval=TRUE, cache=TRUE}
# NOTE: Count and calculate summaries

# load function
source(paste0(FUN.DIR,"simpleClusterSRCountsPerGR.R"))
source(paste0(FUN.DIR,"simpleClusterStatsPerGR.R"))

# Count sequences and reads
SR.COUNTS.DTL <- lapply(names(MAPPED.FILTERED.BAM.L), function(r){
  suppressMessages(
    simpleClusterSRCountsPerGR(GR = MAPPED.FILTERED.BAM.L[[r]], 
                               RANGE.NAME = r,
                               CLUSTER.NAME.COLUMN = "seqnames")) })
names(SR.COUNTS.DTL) <- names(MAPPED.FILTERED.BAM.L)

# Calculate mean and median
R.STAT.DTL <- lapply(names(MAPPED.FILTERED.BAM.L), function(r){
  suppressMessages(
    simpleClusterStatsPerGR(GR = MAPPED.FILTERED.BAM.L[[r]], 
                            RANGE.NAME = r, 
                            CLUSTER.NAME.COLUMN = "seqnames")) })
names(R.STAT.DTL) <- names(MAPPED.FILTERED.BAM.L)

# Create piRNA precursor table
PRECURSOR.DT <- setDT(join_all(dfs = list(join_all(dfs = SR.COUNTS.DTL, 
                                                   by = "CLUSTER", 
                                                   type = "full"),
                                          join_all(dfs = R.STAT.DTL, 
                                                   by = "CLUSTER", 
                                                   type = "full")),
                               by = "CLUSTER", type = "full"))

# Filter: only regions with at least 100 seqeunces
SEQ.CUTOFF = 100
SEQ.CUTOFF.COLUMN <- grep("_Common",grep("seq.count",colnames(PRECURSOR.DT), 
                                         value = TRUE), value = TRUE)
PRECURSOR.FILTERERD.DT <- PRECURSOR.DT[PRECURSOR.DT[[SEQ.CUTOFF.COLUMN]] >= SEQ.CUTOFF]

# Rank: based on the median common piRNA abundance
RANK.COLUMN <- grep("_Common",grep("median",colnames(PRECURSOR.DT), 
                                   value = TRUE),value = TRUE)
setorderv(x = PRECURSOR.FILTERERD.DT, cols = RANK.COLUMN, order = -1)
PRECURSOR.FILTERERD.DT[,paste0(RANK.COLUMN,"_rank") := seq(1,nrow(PRECURSOR.FILTERERD.DT))]
PRECURSOR.FILTERERD.DT[["CLUSTER"]] <- droplevels(PRECURSOR.FILTERERD.DT[["CLUSTER"]])
```

```{r Figure 3 & 4, prepare data, eval=TRUE, cache=TRUE}
# NOTE: Select data for plotting

# Prepare data table needed for box plot
BOX.TABLE.L <- lapply(names(MAPPED.FILTERED.BAM.L), function(r){
  # a range & table
  a.GR <- MAPPED.FILTERED.BAM.L[[r]]
  a.DT <- as.data.table(a.GR)
  
  # subset
  a.DT <- a.DT[,c("seqnames", "MULT")]
  colnames(a.DT) <- c("CLUSTER","abundance")
  a.DT[["sample"]] <- r
  
  # return
  return(a.DT)})

# Calculations
PPM = 1000000
BP.DT <- rbindlist(l = BOX.TABLE.L)
BP.DT[,"total.reads" := sum(mcols(MAPPED.FILTERED.BAM.L[["Total"]])[["MULT"]])]
BP.DT[,"abundance.ppm" := (abundance / total.reads) * PPM]
BP.DT[,"median.abundance.ppm" := lapply(.SD, median), 
      by = c("sample","CLUSTER"), .SDcols = c("abundance.ppm")]
BP.DT[,"mean.abundance.ppm" := lapply(.SD, mean), 
      by = c("sample","CLUSTER"), .SDcols = c("abundance.ppm")]

# Extract ranked information only for piRNA precursors with sufficient data
BP <- BP.DT[CLUSTER %in% PRECURSOR.FILTERERD.DT[["CLUSTER"]]]
BPM <- setDT(join_all(
  dfs = list(BP,PRECURSOR.FILTERERD.DT[,.SD, 
                                       .SDcols= c("CLUSTER",paste0(RANK.COLUMN,"_rank"))]), 
                      by = "CLUSTER", type = "full"))
BPM[["CLUSTER"]] <- factor(BPM[["CLUSTER"]], levels = PRECURSOR.FILTERERD.DT[["CLUSTER"]])


# Subset for graphing
BPM.common <- BPM[sample %in% "Common"]
BPM.rare <- BPM[sample %in% "Rare"]
BP.mean <- BPM[, lapply(.SD, mean), 
               by = c("CLUSTER",paste0(RANK.COLUMN,"_rank"),"sample"), 
               .SDcols = "abundance.ppm"]
BP.mean <- BP.mean[sample %in% c("Common","Rare")]
```

```{r Figure 3A + 4A PLOTS, fig.align="center", eval=TRUE, cache=TRUE}
# NOTE: Plot the results - Figure 3A & Figure 4A

# plot settings
FAM = "Helvetica"; XYT = 12; TCOL = "black"

# plot
ggplot() + theme_pubclean() + 
  ## common
  geom_boxplot(data = BPM.common, aes_string(x = paste0(RANK.COLUMN,"_rank"), 
                                             y = "abundance.ppm", 
                                     group = "CLUSTER", colour = "sample", 
                                     fill = "sample"),
               outlier.shape = NA, coef = 0, lwd = 0.2, 
               colour = "white", fill = "plum3") +
  ## rare
  geom_boxplot(data = BPM.rare, aes_string(x = paste0(RANK.COLUMN,"_rank"), 
                                           y = "abundance.ppm",
                                   group = "CLUSTER", colour = "sample", 
                                   fill = "sample"),
               outlier.shape = NA, coef = 0, lwd = 0.2, 
               colour = "white", fill = "lightseagreen") +
  
  ## points
  geom_point(data = BP.mean, 
             aes_string(x = paste0(RANK.COLUMN,"_rank"), y = "abundance.ppm", 
                        colour = "sample"),
             shape = 16, size = 3, alpha = 0.5) +
  ## scales
  scale_y_continuous(trans = "log10", limits = c(1,100)) + 
  scale_x_continuous(breaks = seq(0,500,5)) +
  scale_colour_manual(values = c("plum3", "lightseagreen")) +
  scale_fill_manual(values = c("plum3", "lightseagreen")) +
  
  ## theme
  annotation_logticks(sides = "l") +
  theme(aspect.ratio = 0.5, 
        axis.ticks.y = element_blank(),
        axis.text = element_text(family = FAM, size = XYT, color = TCOL),
        axis.title = element_text(family = FAM, size = XYT, colour = TCOL))
```

```{r Figure 3D + 4C, first-nucleotide metrics,eval=TRUE, fig.align="center", cache=TRUE}
# NOTE: Calculate first-nucleotide metrics

## load function
source(paste0(FUN.DIR,"simpleClusterFirstNucStatsPerGR.R"))

## extract first nucleotide count and calculate statistics
N1PC.DTL <- lapply(names(MAPPED.FILTERED.BAM.L),function(s){
  suppressMessages(
    simpleClusterFirstNucStatsPerGR(GR = MAPPED.FILTERED.BAM.L[[s]], 
                                    RANGE.NAME = s,
                                    BSSPECIES = "Dmelanogaster",
                                    SOURCE.DIR = FUN.DIR)) })
names(N1PC.DTL) <- names(MAPPED.FILTERED.BAM.L)

## Combine all
N1DT <- setDT(join_all(dfs = N1PC.DTL, by = "CLUSTER", type = "full"))

## Add normalization to parts per million
PPM = 1000000
N1DT[,"mean.T.total.ppm" := (mean.T_Total/total.reads_Total) * PPM]
N1DT[,"mean.A.total.ppm" := (mean.A_Total/total.reads_Total) * PPM]
N1DT[,"mean.G.total.ppm" := (mean.G_Total/total.reads_Total) * PPM]
N1DT[,"mean.C.total.ppm" := (mean.C_Total/total.reads_Total) * PPM]
N1DT[,"mean.AGC.total.ppm" := (mean.AGC_Total/total.reads_Total) * PPM]
N1DT[,"median.T.total.ppm" := (median.T_Total/total.reads_Total) * PPM]
N1DT[,"median.A.total.ppm" := (median.A_Total/total.reads_Total) * PPM]
N1DT[,"median.G.total.ppm" := (median.G_Total/total.reads_Total) * PPM]
N1DT[,"median.C.total.ppm" := (median.C_Total/total.reads_Total) * PPM]
N1DT[,"median.AGC.total.ppm" := (median.AGC_Total/total.reads_Total) * PPM]

## calculate ratios
N1DT[,"rat.UnonU.mean.total.raw" := mean.T_Total / mean.AGC_Total]
N1DT[,"rat_UmeanCluster.total" := mean.T_Total / cluster.mean_Total]
N1DT[,"rat_AmeanCluster.total" := mean.A_Total / cluster.mean_Total]
N1DT[,"rat_CmeanCluster.total" := mean.C_Total / cluster.mean_Total]
N1DT[,"rat_GmeanCluster.total" := mean.G_Total / cluster.mean_Total]
N1DT[,"rat.UnonU.median.total.raw" := median.T_Total / median.AGC_Total]
N1DT[,"rat_UmedianCluster.total" := median.T_Total / cluster.median_Total]
N1DT[,"rat_AmedianCluster.total" := median.A_Total / cluster.median_Total]
N1DT[,"rat_CmedianCluster.total" := median.C_Total / cluster.median_Total]
N1DT[,"rat_GmedianCluster.total" := median.G_Total / cluster.median_Total]

# Combine with ranked order from previous figure and setup for plotting
N1.TAB <- setDT(join_all(dfs = list(N1DT,
                                    BP.mean[sample %in% "Common",
                                            .SD,
                                            .SDcols=c("CLUSTER",paste0(RANK.COLUMN,"_rank") )]), 
                         by = "CLUSTER", type = "full"))
N1.TAB <- na.omit(N1.TAB)
setorderv(N1.TAB, cols = c(paste0(RANK.COLUMN,"_rank")), order = 1)
DT.F3D <- N1.TAB[,.SD,
                 .SDcols=c("CLUSTER",
                           paste0(RANK.COLUMN,"_rank"), 
                           grep("meanCluster",colnames(N1.TAB),value=T))]

DT.F3Dm <- melt.data.table(data = DT.F3D, 
                           id.vars = c("CLUSTER",
                                       paste0(RANK.COLUMN,"_rank")), 
                           variable.name = "nuc", 
                           value.name = "ratio")
```

```{r Figure 3D + 4C PLOT, fig.align="center", eval=TRUE, cache=TRUE}
# NOTE: Figure 3D & 4C plots

# Plot
ggplot() + theme_pubclean() +
  geom_hline(yintercept = 1, linetype = "dashed") +
  
  geom_smooth(data = DT.F3Dm, aes_string(x = paste0(RANK.COLUMN,"_rank"), 
                                         y = "ratio", 
                                         colour = "nuc"), 
              se = FALSE, size = 3, alpha = 0.5) +
  scale_y_continuous(limits = c(0,2)) +
  scale_colour_manual(values = c("firebrick1","goldenrod1","dodgerblue1","forestgreen")) +
  theme(aspect.ratio = 0.5, legend.position = "right",
        axis.text = element_text(family = FAM, size = XYT, color = TCOL),
        axis.title = element_text(family = FAM, size = XYT, colour = TCOL))
```

```{r Figure 3Ain & E, fig.align="center",eval=TRUE, cache=TRUE}
# NOTE: Annotating piRNAs by origin and target

# load function
source(paste0(FUN.DIR,"rmskGTF2BED.R"))
source(paste0(FUN.DIR,"annotateGRanked.R"))
source(paste0(FUN.DIR,"annotateRankedBP.R"))

# load rmsk annotations
RMSK.PATH= "/Users/genzorp/Documents/DATA/Annotation/Dmelanogaster/dm6_rmsk_TE.gtf"
RMSK.GR <- suppressMessages(
  rmskGTF2BED(RMSK.GTF = RMSK.PATH, RETURN.GR = TRUE))

# compare RMSK with piRNA precursors
#OSC.PRECURSORS.GR

# annotation in order CAT1 > CAT2 ... > CAT5
ANOT.DT.L <- suppressMessages(
  annotateGRanked(GR = BIO.REP.U.S249, 
                  SAMPLE.NAME = "biorep", 
                  NH.TAG = 1,
                  SIZE.RANGE = c(24,29),
                  CATEGORY.NAMES = c("PRECURSORS","RMSK"),
                  CATEGORY.1.GR = OSC.PRECURSORS.GR,
                  CATEGORY.2.GR = RMSK.GR, 
                  SOURCE.DIR = FUN.DIR) )

# plot the distribution of annotation categories
annotateRankedBP(ANN.TAB.L = ANOT.DT.L, 
                 COORD.FLIP = TRUE,
                 ASPECT.RATIO = 0.2, 
                 Y.LIMS = c(-60,70))
```


#
# ***bash*** Scripts
#



```{r Counting Callibrators, eval = FALSE}
# NOTE: Bash script used for counting calibrator sequences in the fastq.gz files

#!/bin/bash

# ABOUT
# Find the number of calibrator sequences by looking for their full sequence 
# without mismatches

# inputs
input=$1
name=$(basename ${input%.fastq.gz})

echo "Counting the Calibrators"
printf "Calibrator\nA_CalibratorSequence" > "${name}"_Calibrator_seq.txt

echo "Counts" > "${name}"_Calibrator_Count.txt
zgrep 'CalibratorSequence' "${name}".fastq.gz | wc -l >> "${name}"_Calibrator_Count.txt

paste "${name}"_Calibrator_seq.txt \
      "${name}"_Calibrator_Count.txt > "${name}"_Calibrator_Counts.txt

# remove intermediate files
rm "${name}"_Calibrator_seq.txt
rm "${name}"_Calibrator_Count.txt

echo "Done"
```
